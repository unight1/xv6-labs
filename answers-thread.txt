当两个线程同时执行 put 操作时，可能会出现以下竞争条件序列：
线程A和线程B同时计算相同的哈希桶索引,线程A执行 insert()，将新节点添加到链表头部,线程B也执行 insert()，同样将新节点添加到链表头部
结果:后执行的 insert() 会覆盖先执行的 insert()，导致先插入的键丢失

具体序列：
线程A：insert(key1, value1) → 将 key1 添加到桶链表头部
线程B：insert(key2, value2) → 将 key2 添加到同一个桶链表头部，覆盖了线程A的插入
结果：key1 从哈希表中丢失

这是因为 insert() 操作不是原子性的，多个线程同时修改同一个链表时会发生数据竞争。
